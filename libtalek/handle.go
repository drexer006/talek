package libtalek

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"hash"
	"io"

	"github.com/agl/ed25519"
	"github.com/dchest/siphash"
	"github.com/privacylab/talek/common"
	"github.com/privacylab/talek/drbg"
	"github.com/privacylab/talek/pir/pirclient"
	"golang.org/x/crypto/nacl/box"
)

// Handle is the readable component of a Talek Log.
// Handles are created by making a NewTopic, but can be independently
// shared, and restored from a serialized state. A Handle is read
// by calling Client.Poll(handle) to receive a channel with new messages
// read from the Handle.
type Handle struct {
	// for random looking pir requests
	drbg *drbg.HashDrbg

	// For learning log positions
	Seed1 *drbg.Seed
	Seed2 *drbg.Seed

	// For decrypting messages
	SharedSecret     *[32]byte
	SigningPublicKey *[32]byte

	// Current log position
	Seqno uint64

	// partially read message
	partialMessage message

	// Notifications of new messages
	updates chan []byte

	// Hash function for interest vectors.
	hasher hash.Hash

	// log for messages
	log *common.Logger
}

//NewHandle creates a new topic handle, without attachment to a specific topic.
func NewHandle() (h *Handle, err error) {
	h = &Handle{}
	err = initHandle(h)
	return
}

func initHandle(h *Handle) (err error) {
	h.updates = make(chan []byte)
	h.hasher = sha256.New()

	h.drbg, err = drbg.NewHashDrbg(nil)
	return
}

// nextBuckets returns the pair of buckets that will be used in the next poll or publish of this
// topic given the current sequence number of the handle.
// The buckets returned by this method must still be wrapped by the NumBuckets config
// parameter of talek instance it is requested against.
func (h *Handle) nextBuckets(conf *common.Config) (uint64, uint64) {
	seqNoBytes := make([]byte, 24)
	_ = binary.PutUvarint(seqNoBytes, h.Seqno)

	k0, k1 := h.Seed1.KeyUint128()
	b1 := siphash.Hash(k0, k1, seqNoBytes)
	k0, k1 = h.Seed2.KeyUint128()
	b2 := siphash.Hash(k0, k1, seqNoBytes)
	b1 = b1 % conf.NumBuckets
	b2 = b2 % conf.NumBuckets

	return b1, b2
}

// nextInterestVector returns the bytes that will be used to set the bloom filter location
// the next time this handle is written to.
func (h *Handle) nextInterestVector() []byte {
	var seqNoBytes [24]byte
	_ = binary.PutUvarint(seqNoBytes[:], h.Seqno)
	interestKey := append(h.SigningPublicKey[:], seqNoBytes[:]...)
	return h.hasher.Sum(interestKey)
}

func makeReadArg(config *ClientConfig, bucket uint64, rand io.Reader) *common.ReadArgs {
	arg := &common.ReadArgs{}
	num := len(config.TrustDomains)
	arg.TD = make([]common.PirArgs, num)

	pirClient := pirclient.NewClient("pirclient")
	reqVec, err := pirClient.GenerateRequestVectors(bucket, uint64(num), config.Config.NumBuckets)
	if err != nil {
		return nil
	}

	for i := 0; i < num; i++ {
		arg.TD[i].RequestVector = reqVec[i]
		arg.TD[i].PadSeed = make([]byte, drbg.SeedLength)
		if _, err := rand.Read(arg.TD[i].PadSeed); err != nil {
			return nil
		}

	}

	return arg
}

func (h *Handle) generatePoll(config *ClientConfig, rand io.Reader) (*common.ReadArgs, *common.ReadArgs, error) {
	if h.SharedSecret == nil || h.SigningPublicKey == nil {
		return nil, nil, errors.New("Subscription not fully initialized")
	}

	args := make([]*common.ReadArgs, 2)
	bucket1, bucket2 := h.nextBuckets(config.Config)

	args[0] = makeReadArg(config, bucket1, rand)
	args[1] = makeReadArg(config, bucket2, rand)

	return args[0], args[1], nil
}

// Decrypt attempts decryption of a message for a topic using a specific nonce.
func (h *Handle) Decrypt(cyphertext []byte, nonce *[24]byte) ([]byte, error) {
	if h.SharedSecret == nil || h.SigningPublicKey == nil {
		return nil, errors.New("Handle improperly initialized")
	}
	cypherlen := len(cyphertext)
	if cypherlen < ed25519.SignatureSize {
		return nil, errors.New("Invalid cyphertext")
	}

	//verify signature
	message := cyphertext[0 : cypherlen-ed25519.SignatureSize]
	var sig [ed25519.SignatureSize]byte
	copy(sig[:], cyphertext[cypherlen-ed25519.SignatureSize:])
	if !ed25519.Verify(h.SigningPublicKey, message, &sig) {
		return nil, errors.New("Invalid Signature")
	}

	//decrypt
	plaintext := make([]byte, 0, cypherlen-box.Overhead-ed25519.SignatureSize)
	_, ok := box.OpenAfterPrecomputation(plaintext, message, nonce, h.SharedSecret)
	if !ok {
		return nil, errors.New("Failed to decrypt")
	}
	return plaintext[0:cap(plaintext)], nil
}

// OnResponse processes a response for a request generated by generatePoll,
// sending it to the handle's updates channel if valid.
func (h *Handle) OnResponse(args *common.ReadArgs, reply *common.ReadReply, dataSize uint) {
	msg := h.retrieveResponse(args, reply, dataSize)
	if msg != nil {
		h.Seqno++

		if h.partialMessage.Join(msg) {
			if h.updates != nil {
				h.updates <- h.partialMessage.Retrieve()
			}
			h.partialMessage = message{}
		}
	}
}

func (h *Handle) retrieveResponse(args *common.ReadArgs, reply *common.ReadReply, dataSize uint) []byte {
	data := reply.Data

	// strip out the padding injected by trust domains.
	for i := 0; i < len(args.TD); i++ {
		if err := drbg.Overlay(args.TD[i].PadSeed, data); err != nil {
			if h.log != nil {
				h.log.Info.Printf("Failed to remove pad on returned read: %v\n", err)
			}
			return nil
		}
	}

	var seqNoBytes [24]byte
	_ = binary.PutUvarint(seqNoBytes[:], h.Seqno)

	// A 'bucket' likely has multiple messages in it. See if any of them are ours.
	for i := uint(0); i < uint(len(data)); i += dataSize {
		plaintext, err := h.Decrypt(data[i:i+dataSize], &seqNoBytes)
		if err == nil {
			if h.log != nil {
				h.log.Trace.Printf("Successful Decryption.\n")
			}
			return plaintext
		}

		if h.log != nil {
			h.log.Trace.Printf("decryption failed for read %d of bucket %d [%v](%d): %v\n",
				i/dataSize,
				args.Bucket(),
				data[i:i+4],
				len(data[i:i+dataSize]),
				err)
		}
	}
	return nil
}

// MarshalText is a compact textual representation of a handle
func (h *Handle) MarshalText() ([]byte, error) {
	s1, err := h.Seed1.MarshalBinary()
	if err != nil {
		return nil, err
	}
	s2, err := h.Seed2.MarshalBinary()
	if err != nil {
		return nil, err
	}
	txt := fmt.Sprintf("%x.%x.%x.%x.%d", s1, s2, *h.SharedSecret, *h.SigningPublicKey, h.Seqno)
	return []byte(txt), nil
}

// UnmarshalText restores a handle from its compact textual representation
func (h *Handle) UnmarshalText(text []byte) error {
	var s1, s2, ss, pk []byte
	if n, err := fmt.Sscanf(string(text), "%x.%x.%x.%x.%d", &s1, &s2, &ss, &pk, &h.Seqno); n < 5 || err != nil {
		if err != nil {
			return err
		}
		return errors.New("invalid handle")
	}
	h.SharedSecret = new([32]byte)
	copy(h.SharedSecret[:], ss)
	h.SigningPublicKey = new([32]byte)
	copy(h.SigningPublicKey[:], pk)
	h.Seed1 = &drbg.Seed{}
	h.Seed2 = &drbg.Seed{}
	if err := h.Seed1.UnmarshalBinary(s1); err != nil {
		return err
	}
	if err := h.Seed2.UnmarshalBinary(s2); err != nil {
		return err
	}
	if err := initHandle(h); err != nil {
		return err
	}
	return nil
}

// Equal tests equality of two handles
func Equal(a, b *Handle) bool {
	if a.Seqno != b.Seqno {
		return false
	}
	if !bytes.Equal(a.SharedSecret[:], b.SharedSecret[:]) ||
		!bytes.Equal(a.SigningPublicKey[:], b.SigningPublicKey[:]) {
		return false
	}
	if (drbg.Equal(a.Seed1, b.Seed1) && drbg.Equal(a.Seed2, b.Seed2)) || (drbg.Equal(a.Seed1, b.Seed2) && drbg.Equal(a.Seed2, b.Seed1)) {
		return true
	}
	return false
}
